
alias userSP R0;
userSP = SP;

//set Mode Flag to syscall 9
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 9;

//save user SP and change SP value
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP;
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;

alias arg R1;
arg = [([PTBR + 2*((userSP - 4)/512)] * 512) + ((userSP-4) %512)];

//Checking if arg present in Inode Table

alias incrementer R2;
incrementer = 0;

while(incrementer < MAX_FILE_NUM )do
    if ( [ INODE_TABLE + (incrementer * 16) + 1 ] == arg )then
        break;
    endif;
    incrementer = incrementer + 1;
endwhile;

alias index R9;
index = incrementer;

//If no such file exists or not in XEXE format 
if ( index == MAX_FILE_NUM || [ INODE_TABLE + ( index * 16 ) ] != EXEC )then
    [([PTBR + 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512)] = -1;
    
    // Reset Mode Flag
    [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;

    //Reset Stack pointer
    SP = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13];
    ireturn;
endif;
//calling exit process

multipush(R0,R1,R2);

R1 = 3;
R2 = [SYSTEM_STATUS_TABLE + 1];
call PROCESS_MANAGER;
multipop(R0,R1,R2);

//Reclaiming UAPage
alias UAPage R3;
UAPage = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11];
[MEMORY_FREE_LIST + UAPage] = [MEMORY_FREE_LIST + UAPage] + 1;
[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;

//New Kernel Stack initialised from the bottom without offset
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1;

alias perprocess R4;
perprocess = (UAPage*512) + RESOURCE_TABLE_OFFSET;
while ( perprocess < (UAPage+1)*512 )do
    [perprocess] = -1;
    perprocess = perprocess + 2;
endwhile;


//STATE field set
[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 4] = RUNNING;

//Inode index set
[PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 7] = index;

//Allocating Pages

PTBR = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 14];
PTLR = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 15];

//Library
[PTBR+0] = 63;
[PTBR+1] = "0100";
[PTBR+2] = 64;
[PTBR+3] = "0100";

//Heap
[PTBR+4] = -1;
[PTBR+5] = "0000";
[PTBR+6] = -1;
[PTBR+7] = "0000";

//Stack 2 pages
multipush(R0,R1,R2,R3);

R1 = 1;
call MEMORY_MANAGER;
[PTBR + 16] = R0;
[PTBR + 17] = "0110";

R1 = 1;
call MEMORY_MANAGER;
[PTBR + 18] = R0;
[PTBR + 19] = "0110";

multipop(R0,R1,R2,R3);



//Code
//Get Code Page (Assigning First Code Block a memory page)

multipush(R0,R1,R2,R3,R4);

R1 = 5;
R2 = [ INODE_TABLE + ( index * 16 ) + 8 ];
R3 = [SYSTEM_STATUS_TABLE + 1];

call MEMORY_MANAGER;

[ PTBR + 8 ] = R0;
[ PTBR + 9 ] = "0100";

multipop(R0,R1,R2,R3,R4);


[PTBR+10] = -1;
[PTBR+11] = "0000";
[PTBR+12] = -1;
[PTBR+13] = "0000";
[PTBR+14] = -1;
[PTBR+15] = "0000";


//Initialising Disk Map Table

alias counter R4;
alias currentPID R5;
currentPID = [SYSTEM_STATUS_TABLE + 1];
counter=0;
while(counter < 10)do
    [ DISK_MAP_TABLE + currentPID*10 + counter] = -1;
    counter = counter + 1;
endwhile;

[DISK_MAP_TABLE + currentPID*10 + 4] =  [INODE_TABLE + ( index * 16 ) + 8];
[DISK_MAP_TABLE + currentPID*10 + 5] =  [INODE_TABLE + ( index * 16 ) + 9];
[DISK_MAP_TABLE + currentPID*10 + 6] =  [INODE_TABLE + ( index * 16 ) + 10];
[DISK_MAP_TABLE + currentPID*10 + 7] =  [INODE_TABLE + ( index * 16 ) + 11];



[[PTBR + 16] * 512] = [[PTBR + 8] * 512 + 1];

// Reset Mode Flag
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;

SP = 8 * 512;
ireturn;
